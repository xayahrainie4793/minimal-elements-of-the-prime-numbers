This set of C++ (https://en.wikipedia.org/wiki/C%2B%2B) programs must be run with *GMP* (https://en.wikipedia.org/wiki/GNU_Multiple_Precision_Arithmetic_Library, https://gmplib.org/)

This set of programs uses many number theoretic (https://en.wikipedia.org/wiki/Number_theory, https://www.rieselprime.de/ziki/Number_theory, https://mathworld.wolfram.com/NumberTheory.html) functions in *GMP* library (see https://gmplib.org/manual/Number-Theoretic-Functions.html), and we use the *GMP* function *mpz_probab_prime_p* (see https://faculty.lynchburg.edu/~nicely/misc/mpzspsp) to test the probable primality of the numbers, this function is combination of the Baillie-PSW probable primality test (https://en.wikipedia.org/wiki/Baillie%E2%80%93PSW_primality_test, https://mathworld.wolfram.com/Baillie-PSWPrimalityTest.html), the Miller-Rabin probable primality test (https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test, https://primes.utm.edu/glossary/xpage/MillersTest.html, https://www.rieselprime.de/ziki/Miller-Rabin_pseudoprimality_test, https://mathworld.wolfram.com/Rabin-MillerStrongPseudoprimeTest.html) of first 26 prime bases (see https://oeis.org/A014233) (we use reps = 50, thus the first 50−24 = 26 prime bases), and trial division (https://en.wikipedia.org/wiki/Trial_division, https://primes.utm.edu/glossary/xpage/TrialDivision.html, https://www.rieselprime.de/ziki/Trial_factoring, https://mathworld.wolfram.com/TrialDivision.html) to about 10<sup>9</sup>, thus all numbers in the data are Baillie-PSW probable primes (i.e. both strong probable primes to base 2 (see https://oeis.org/A001262) and strong Lucas pseudoprimes with parameters (*P*, *Q*) defined by Selfridge's Method *A* (see https://oeis.org/A217255)), i.e. either primes or Baillie-PSW pseudoprimes, and no known composites which pass the Baillie–PSW probable prime test, and no composites < 2<sup>64</sup> pass the Baillie–PSW probable prime test (see http://ntheory.org/pseudoprimes.html and https://faculty.lynchburg.edu/~nicely/misc/bpsw.html), thus if a number in the data is in fact composite, it will be a pseudoprime to the Baillie–PSW probable prime test, which currently no single example is known!

The program "searchLLR.cc" is a sieving (https://www.rieselprime.de/ziki/Sieving, https://mathworld.wolfram.com/Sieve.html) program like *SRSIEVE* (https://www.bc-team.org/app.php/dlext/?cat=3, https://mersenneforum.org/attachment.php?attachmentid=16377&d=1499103807, http://web.archive.org/web/20160922072340/https://sites.google.com/site/geoffreywalterreynolds/programs/, http://www.rieselprime.de/dl/CRUS_pack.zip, https://primes.utm.edu/bios/page.php?id=905, https://www.rieselprime.de/ziki/Srsieve, https://github.com/xayahrainie4793/prime-programs-cached-copy/tree/main/srsieve_1.1.4, https://github.com/xayahrainie4793/prime-programs-cached-copy/tree/main/sr1sieve_1.4.6, https://github.com/xayahrainie4793/prime-programs-cached-copy/tree/main/sr2sieve_2.0.0, https://github.com/xayahrainie4793/prime-programs-cached-copy/tree/main/srbsieve) but only sieved to the prime 130337 (while *SRSIEVE* usually sieve to 10<sup>9</sup> or more) and not remove the numbers with algebraic factors (see https://mersenneforum.org/showpost.php?p=452132&postcount=66 and https://mersenneforum.org/showthread.php?t=21916 and https://github.com/xayahrainie4793/prime-programs-cached-copy/blob/main/srsieve_1.1.4/algebraic.c), and the program "searchLLR.cc" prints the *LLR* (http://jpenne.free.fr/index2.html, https://primes.utm.edu/bios/page.php?id=431, https://www.rieselprime.de/ziki/LLR, https://github.com/xayahrainie4793/prime-programs-cached-copy/tree/main/llr403win64, https://github.com/xayahrainie4793/prime-programs-cached-copy/tree/main/llr403linux64) input file and thus the *LLR* program must be used after the program "searchLLR.cc".
